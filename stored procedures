-- =====================================================
-- RAILWAY RESERVATION SYSTEM - ADO.NET READY PROCEDURES
-- All inputs dynamic, no hardcoded values, production ready
-- =====================================================

-- =====================================================
-- 1. TRIGGERS (Auto-executed on data changes)
-- =====================================================

-- A. Auto-generate seat availability when train is added
CREATE TRIGGER trg_train_insert_availability
ON trains AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @train_id INT, @sleeper INT, @ac3 INT, @ac2 INT;
    
    SELECT @train_id = train_id, @sleeper = sleeper_seats, 
           @ac3 = ac3_seats, @ac2 = ac2_seats 
    FROM inserted;
    
    -- Generate availability for next 120 days
    WITH DateRange AS (
        SELECT CAST(GETDATE() AS DATE) as journey_date
        UNION ALL
        SELECT DATEADD(day, 1, journey_date)
        FROM DateRange
        WHERE journey_date < DATEADD(day, 120, CAST(GETDATE() AS DATE))
    )
    INSERT INTO seat_availability (train_id, journey_date, sleeper_available, ac3_available, ac2_available)
    SELECT @train_id, journey_date, @sleeper, @ac3, @ac2
    FROM DateRange
    OPTION (MAXRECURSION 150);
END;

-- B. Update seat availability when booking is made
CREATE TRIGGER trg_passenger_seat_update
ON passengers AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;
    
    UPDATE sa
    SET sleeper_available = CASE WHEN i.seat_type = 'sleeper' THEN sa.sleeper_available - 1 ELSE sa.sleeper_available END,
        ac3_available = CASE WHEN i.seat_type = 'ac3' THEN sa.ac3_available - 1 ELSE sa.ac3_available END,
        ac2_available = CASE WHEN i.seat_type = 'ac2' THEN sa.ac2_available - 1 ELSE sa.ac2_available END,
        last_updated = GETDATE()
    FROM seat_availability sa
    INNER JOIN bookings b ON sa.train_id = b.train_id
    INNER JOIN inserted i ON b.booking_id = i.booking_id
    WHERE sa.journey_date = b.journey_date;
END;

-- C. Restore seat availability when booking is cancelled
CREATE TRIGGER trg_passenger_seat_restore
ON passengers AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Only when status changes to cancelled
    IF UPDATE(status)
    BEGIN
        UPDATE sa
        SET sleeper_available = CASE WHEN i.seat_type = 'sleeper' AND i.status = 'cancelled' AND d.status != 'cancelled' 
                                     THEN sa.sleeper_available + 1 ELSE sa.sleeper_available END,
            ac3_available = CASE WHEN i.seat_type = 'ac3' AND i.status = 'cancelled' AND d.status != 'cancelled'
                                 THEN sa.ac3_available + 1 ELSE sa.ac3_available END,
            ac2_available = CASE WHEN i.seat_type = 'ac2' AND i.status = 'cancelled' AND d.status != 'cancelled'
                                 THEN sa.ac2_available + 1 ELSE sa.ac2_available END,
            last_updated = GETDATE()
        FROM seat_availability sa
        INNER JOIN bookings b ON sa.train_id = b.train_id
        INNER JOIN inserted i ON b.booking_id = i.booking_id
        INNER JOIN deleted d ON i.passenger_id = d.passenger_id
        WHERE sa.journey_date = b.journey_date;
    END;
END;

-- =====================================================
-- 2. USER AUTHENTICATION & MANAGEMENT
-- =====================================================

-- A. User Registration
CREATE PROCEDURE sp_RegisterUser
    @Name NVARCHAR(100),
    @Email NVARCHAR(255),
    @Phone NVARCHAR(15),
    @Password NVARCHAR(255),
    @DateOfBirth DATE = NULL,
    @Gender NVARCHAR(10) = NULL,
    @UserType NVARCHAR(10) = 'customer'
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        -- Check if email already exists
        IF EXISTS(SELECT 1 FROM users WHERE email = @Email)
        BEGIN
            SELECT 0 as Success, 'Email already registered' as Message, 0 as UserId;
            RETURN;
        END
        
        -- Check if phone already exists
        IF EXISTS(SELECT 1 FROM users WHERE phone = @Phone)
        BEGIN
            SELECT 0 as Success, 'Phone number already registered' as Message, 0 as UserId;
            RETURN;
        END
        
        DECLARE @UserId INT;
        
        INSERT INTO users (name, email, phone, password_hash, date_of_birth, gender, user_type)
        VALUES (@Name, @Email, @Phone, @Password, @DateOfBirth, @Gender, @UserType);
        
        SET @UserId = SCOPE_IDENTITY();
        
        SELECT 1 as Success, 'User registered successfully' as Message, @UserId as UserId;
        
    END TRY
    BEGIN CATCH
        SELECT 0 as Success, ERROR_MESSAGE() as Message, 0 as UserId;
    END CATCH
END;

-- B. User Login
CREATE PROCEDURE sp_LoginUser
    @Email NVARCHAR(255),
    @Password NVARCHAR(255)
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        CASE WHEN password_hash = @Password AND is_active = 1 THEN 1 ELSE 0 END as Success,
        user_id,
        name,
        email,
        phone,
        user_type,
        CASE WHEN password_hash = @Password AND is_active = 1 
             THEN 'Login successful' 
             WHEN is_active = 0 
             THEN 'Account is deactivated'
             ELSE 'Invalid credentials' 
        END as Message
    FROM users 
    WHERE email = @Email;
END;

-- =====================================================
-- 3. STATION MANAGEMENT
-- =====================================================

-- A. Get All Active Stations
CREATE PROCEDURE sp_GetAllStations
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT station_id, station_name, station_code, state
    FROM stations 
    WHERE is_active = 1
    ORDER BY station_name;
END;

-- B. Search Stations by Name/Code
CREATE PROCEDURE sp_SearchStations
    @SearchTerm NVARCHAR(100)
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT station_id, station_name, station_code, state
    FROM stations 
    WHERE is_active = 1
      AND (station_name LIKE '%' + @SearchTerm + '%' 
           OR station_code LIKE '%' + @SearchTerm + '%')
    ORDER BY station_name;
END;

-- =====================================================
-- 4. TRAIN SEARCH & AVAILABILITY
-- =====================================================

-- A. Search Available Trains (ADO.NET Ready)
CREATE PROCEDURE sp_SearchTrains
    @SourceStationId INT,
    @DestinationStationId INT,
    @JourneyDate DATE,
    @SeatType NVARCHAR(10) = 'sleeper',
    @PassengerCount INT = 1
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @DayOfWeek INT = DATEPART(weekday, @JourneyDate);
    
    SELECT 
        t.train_id,
        t.train_number,
        t.train_name,
        s1.station_name as source_station,
        s1.station_code as source_code,
        s2.station_name as destination_station,
        s2.station_code as destination_code,
        t.departure_time,
        t.arrival_time,
        CASE @SeatType
            WHEN 'sleeper' THEN ISNULL(sa.sleeper_available, 0)
            WHEN 'ac3' THEN ISNULL(sa.ac3_available, 0)
            WHEN 'ac2' THEN ISNULL(sa.ac2_available, 0)
        END as available_seats,
        CASE @SeatType
            WHEN 'sleeper' THEN t.sleeper_fare
            WHEN 'ac3' THEN t.ac3_fare
            WHEN 'ac2' THEN t.ac2_fare
        END as fare_per_passenger,
        (CASE @SeatType
            WHEN 'sleeper' THEN t.sleeper_fare
            WHEN 'ac3' THEN t.ac3_fare
            WHEN 'ac2' THEN t.ac2_fare
        END * @PassengerCount) as total_fare,
        CASE 
            WHEN CASE @SeatType
                WHEN 'sleeper' THEN ISNULL(sa.sleeper_available, 0)
                WHEN 'ac3' THEN ISNULL(sa.ac3_available, 0)
                WHEN 'ac2' THEN ISNULL(sa.ac2_available, 0)
            END >= @PassengerCount THEN 'AVAILABLE'
            ELSE 'WAITLIST'
        END as booking_status
    FROM trains t
    INNER JOIN stations s1 ON t.source_station_id = s1.station_id
    INNER JOIN stations s2 ON t.destination_station_id = s2.station_id
    LEFT JOIN seat_availability sa ON t.train_id = sa.train_id AND sa.journey_date = @JourneyDate
    WHERE t.source_station_id = @SourceStationId 
      AND t.destination_station_id = @DestinationStationId
      AND t.is_active = 1
      AND s1.is_active = 1
      AND s2.is_active = 1
      AND LEN(t.running_days) >= @DayOfWeek
      AND SUBSTRING(t.running_days, @DayOfWeek, 1) = '1'
    ORDER BY t.departure_time;
END;

-- B. Get Train Details
CREATE PROCEDURE sp_GetTrainDetails
    @TrainId INT,
    @JourneyDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        t.*,
        s1.station_name as source_station,
        s1.station_code as source_code,
        s2.station_name as destination_station,
        s2.station_code as destination_code,
        sa.sleeper_available,
        sa.ac3_available,
        sa.ac2_available,
        sa.sleeper_waitlist,
        sa.ac3_waitlist,
        sa.ac2_waitlist
    FROM trains t
    INNER JOIN stations s1 ON t.source_station_id = s1.station_id
    INNER JOIN stations s2 ON t.destination_station_id = s2.station_id
    LEFT JOIN seat_availability sa ON t.train_id = sa.train_id AND sa.journey_date = @JourneyDate
    WHERE t.train_id = @TrainId;
END;

-- =====================================================
-- 5. BOOKING OPERATIONS
-- =====================================================

-- A. Make Booking (Complete ADO.NET Ready)
CREATE PROCEDURE sp_MakeBooking
    @UserId INT,
    @TrainId INT,
    @JourneyDate DATE,
    @PassengerCount INT,
    @SeatType NVARCHAR(10),
    @PaymentMethod NVARCHAR(20),
    @TransactionId NVARCHAR(100),
    @PassengerNames NVARCHAR(MAX), -- Comma separated: "John Doe,Jane Smith"
    @PassengerAges NVARCHAR(100),  -- Comma separated: "30,25"
    @PassengerGenders NVARCHAR(100), -- Comma separated: "male,female"
    @BookingId INT OUTPUT,
    @PNRNumber NVARCHAR(20) OUTPUT,
    @TotalAmount DECIMAL(10,2) OUTPUT,
    @Status NVARCHAR(20) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        -- Validate train and get fare
        DECLARE @FarePerPassenger DECIMAL(8,2);
        DECLARE @AvailableSeats INT;
        
        SELECT 
            @FarePerPassenger = CASE @SeatType
                WHEN 'sleeper' THEN sleeper_fare
                WHEN 'ac3' THEN ac3_fare
                WHEN 'ac2' THEN ac2_fare
            END
        FROM trains 
        WHERE train_id = @TrainId AND is_active = 1;
        
        IF @FarePerPassenger IS NULL
        BEGIN
            SELECT 0 as Success, 'Invalid train or seat type' as Message;
            ROLLBACK TRANSACTION;
            RETURN;
        END
        
        -- Check availability
        SELECT 
            @AvailableSeats = CASE @SeatType
                WHEN 'sleeper' THEN ISNULL(sleeper_available, 0)
                WHEN 'ac3' THEN ISNULL(ac3_available, 0)
                WHEN 'ac2' THEN ISNULL(ac2_available, 0)
            END
        FROM seat_availability
        WHERE train_id = @TrainId AND journey_date = @JourneyDate;
        
        -- Determine booking status
        SET @Status = CASE WHEN @AvailableSeats >= @PassengerCount THEN 'confirmed' ELSE 'waitlist' END;
        SET @TotalAmount = @FarePerPassenger * @PassengerCount;
        
        -- Create main booking
        INSERT INTO bookings (user_id, train_id, journey_date, passenger_count, total_amount, booking_status)
        VALUES (@UserId, @TrainId, @JourneyDate, @PassengerCount, @TotalAmount, @Status);
        
        SET @BookingId = SCOPE_IDENTITY();
        SELECT @PNRNumber = pnr_number FROM bookings WHERE booking_id = @BookingId;
        
        -- Parse and insert passengers
        DECLARE @Counter INT = 1;
        DECLARE @Name NVARCHAR(100), @Age INT, @Gender NVARCHAR(10);
        DECLARE @Names TABLE(id INT IDENTITY, name NVARCHAR(100));
        DECLARE @Ages TABLE(id INT IDENTITY, age INT);
        DECLARE @Genders TABLE(id INT IDENTITY, gender NVARCHAR(10));
        
        -- Split comma-separated values
        INSERT INTO @Names SELECT value FROM STRING_SPLIT(@PassengerNames, ',');
        INSERT INTO @Ages SELECT CAST(value AS INT) FROM STRING_SPLIT(@PassengerAges, ',');
        INSERT INTO @Genders SELECT value FROM STRING_SPLIT(@PassengerGenders, ',');
        
        -- Insert passenger records
        INSERT INTO passengers (booking_id, name, age, gender, seat_type, fare_paid, status)
        SELECT 
            @BookingId,
            LTRIM(RTRIM(n.name)),
            a.age,
            LTRIM(RTRIM(g.gender)),
            @SeatType,
            @FarePerPassenger,
            CASE WHEN @Status = 'confirmed' THEN 'confirmed' ELSE 'waitlist' END
        FROM @Names n
        INNER JOIN @Ages a ON n.id = a.id
        INNER JOIN @Genders g ON n.id = g.id;
        
        -- Record payment
        INSERT INTO payments (booking_id, amount, payment_method, transaction_id)
        VALUES (@BookingId, @TotalAmount, @PaymentMethod, @TransactionId);
        
        COMMIT TRANSACTION;
        
        SELECT 1 as Success, 'Booking created successfully' as Message, 
               @PNRNumber as PNR, @TotalAmount as Amount, @Status as BookingStatus;
        
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        SELECT 0 as Success, ERROR_MESSAGE() as Message, 
               NULL as PNR, 0 as Amount, 'failed' as BookingStatus;
    END CATCH
END;

-- B. Cancel Booking
CREATE PROCEDURE sp_CancelBooking
    @PNRNumber NVARCHAR(20),
    @UserId INT,
    @CancellationReason NVARCHAR(200) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        DECLARE @BookingId INT, @TotalAmount DECIMAL(10,2), @RefundAmount DECIMAL(10,2);
        DECLARE @JourneyDate DATE, @CurrentDate DATE = CAST(GETDATE() AS DATE);
        
        -- Get booking details
        SELECT @BookingId = booking_id, @TotalAmount = total_amount, @JourneyDate = journey_date
        FROM bookings 
        WHERE pnr_number = @PNRNumber 
          AND user_id = @UserId 
          AND booking_status = 'confirmed';
        
        IF @BookingId IS NULL
        BEGIN
            SELECT 0 as Success, 'Booking not found or already cancelled' as Message, 0 as RefundAmount;
            ROLLBACK TRANSACTION;
            RETURN;
        END
        
        -- Calculate refund based on cancellation timing
        DECLARE @DaysToJourney INT = DATEDIFF(day, @CurrentDate, @JourneyDate);
        SET @RefundAmount = CASE 
            WHEN @DaysToJourney >= 1 THEN @TotalAmount * 0.9  -- 90% refund
            WHEN @DaysToJourney >= 0 THEN @TotalAmount * 0.5  -- 50% refund same day
            ELSE 0 -- No refund after journey date
        END;
        
        -- Update booking status
        UPDATE bookings 
        SET booking_status = 'cancelled', payment_status = 'refunded'
        WHERE booking_id = @BookingId;
        
        -- Update passenger status
        UPDATE passengers 
        SET status = 'cancelled'
        WHERE booking_id = @BookingId;
        
        -- Record refund
        UPDATE payments 
        SET refund_amount = @RefundAmount, refund_time = GETDATE()
        WHERE booking_id = @BookingId;
        
        COMMIT TRANSACTION;
        
        SELECT 1 as Success, 'Booking cancelled successfully' as Message, @RefundAmount as RefundAmount;
        
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        SELECT 0 as Success, ERROR_MESSAGE() as Message, 0 as RefundAmount;
    END CATCH
END;

-- C. Get User Bookings
CREATE PROCEDURE sp_GetUserBookings
    @UserId INT,
    @BookingStatus NVARCHAR(20) = NULL, -- NULL = all, or specific status
    @PageNumber INT = 1,
    @PageSize INT = 10
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;
    
    SELECT 
        b.booking_id,
        b.pnr_number,
        b.journey_date,
        b.passenger_count,
        b.total_amount,
        b.booking_status,
        b.payment_status,
        b.booking_time,
        t.train_number,
        t.train_name,
        s1.station_name as source_station,
        s2.station_name as destination_station,
        t.departure_time,
        t.arrival_time
    FROM bookings b
    INNER JOIN trains t ON b.train_id = t.train_id
    INNER JOIN stations s1 ON t.source_station_id = s1.station_id
    INNER JOIN stations s2 ON t.destination_station_id = s2.station_id
    WHERE b.user_id = @UserId
      AND (@BookingStatus IS NULL OR b.booking_status = @BookingStatus)
    ORDER BY b.booking_time DESC
    OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY;
    
    -- Return total count for pagination
    SELECT COUNT(*) as TotalRecords
    FROM bookings b
    WHERE b.user_id = @UserId
      AND (@BookingStatus IS NULL OR b.booking_status = @BookingStatus);
END;

-- D. Get Booking Details with Passengers
CREATE PROCEDURE sp_GetBookingDetails
    @PNRNumber NVARCHAR(20),
    @UserId INT = NULL -- NULL for admin access
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Booking details
    SELECT 
        b.booking_id,
        b.pnr_number,
        b.journey_date,
        b.passenger_count,
        b.total_amount,
        b.booking_status,
        b.payment_status,
        b.booking_time,
        t.train_number,
        t.train_name,
        s1.station_name as source_station,
        s1.station_code as source_code,
        s2.station_name as destination_station,
        s2.station_code as destination_code,
        t.departure_time,
        t.arrival_time,
        u.name as user_name,
        u.email as user_email,
        u.phone as user_phone,
        p.amount as paid_amount,
        p.payment_method,
        p.transaction_id,
        p.refund_amount,
        p.refund_time
    FROM bookings b
    INNER JOIN trains t ON b.train_id = t.train_id
    INNER JOIN stations s1 ON t.source_station_id = s1.station_id
    INNER JOIN stations s2 ON t.destination_station_id = s2.station_id
    INNER JOIN users u ON b.user_id = u.user_id
    LEFT JOIN payments p ON b.booking_id = p.booking_id
    WHERE b.pnr_number = @PNRNumber
      AND (@UserId IS NULL OR b.user_id = @UserId);
    
    -- Passenger details
    SELECT 
        passenger_id,
        name,
        age,
        gender,
        seat_type,
        seat_number,
        coach_number,
        fare_paid,
        status
    FROM passengers p
    INNER JOIN bookings b ON p.booking_id = b.booking_id
    WHERE b.pnr_number = @PNRNumber
      AND (@UserId IS NULL OR b.user_id = @UserId)
    ORDER BY p.passenger_id;
END;

-- =====================================================
-- 6. HELPER FUNCTIONS (ADO.NET Compatible)
-- =====================================================

-- A. Check seat availability
CREATE FUNCTION fn_GetSeatAvailability(
    @TrainId INT,
    @JourneyDate DATE,
    @SeatType NVARCHAR(10)
)
RETURNS INT
AS
BEGIN
    DECLARE @AvailableSeats INT = 0;
    
    SELECT @AvailableSeats = 
        CASE @SeatType
            WHEN 'sleeper' THEN ISNULL(sleeper_available, 0)
            WHEN 'ac3' THEN ISNULL(ac3_available, 0)
            WHEN 'ac2' THEN ISNULL(ac2_available, 0)
            ELSE 0
        END
    FROM seat_availability
    WHERE train_id = @TrainId AND journey_date = @JourneyDate;
    
    RETURN @AvailableSeats;
END;

-- B. Calculate fare
CREATE FUNCTION fn_CalculateFare(
    @TrainId INT,
    @SeatType NVARCHAR(10),
    @PassengerCount INT
)
RETURNS DECIMAL(10,2)
AS
BEGIN
    DECLARE @TotalFare DECIMAL(10,2) = 0;
    
    SELECT @TotalFare = @PassengerCount * 
        CASE @SeatType
            WHEN 'sleeper' THEN sleeper_fare
            WHEN 'ac3' THEN ac3_fare
            WHEN 'ac2' THEN ac2_fare
            ELSE 0
        END
    FROM trains
    WHERE train_id = @TrainId;
    
    RETURN ISNULL(@TotalFare, 0);
END;

-- C. Validate journey date
CREATE FUNCTION fn_IsValidJourneyDate(
    @TrainId INT,
    @JourneyDate DATE
)
RETURNS BIT
AS
BEGIN
    DECLARE @IsValid BIT = 0;
    DECLARE @DayOfWeek INT = DATEPART(weekday, @JourneyDate);
    DECLARE @RunningDays NVARCHAR(7);
    DECLARE @CurrentDate DATE = CAST(GETDATE() AS DATE);
    
    -- Check if journey date is not in past
    IF @JourneyDate < @CurrentDate
        RETURN 0;
    
    SELECT @RunningDays = running_days 
    FROM trains 
    WHERE train_id = @TrainId AND is_active = 1;
    
    IF @RunningDays IS NOT NULL AND LEN(@RunningDays) >= @DayOfWeek
    BEGIN
        SET @IsValid = CASE WHEN SUBSTRING(@RunningDays, @DayOfWeek, 1) = '1' THEN 1 ELSE 0 END;
    END;
    
    RETURN @IsValid;
END;

-- =====================================================
-- 7. ADMIN PROCEDURES
-- =====================================================

-- A. Get Booking Reports
CREATE PROCEDURE sp_GetBookingReports
    @FromDate DATE,
    @ToDate DATE,
    @TrainId INT = NULL,
    @BookingStatus NVARCHAR(20) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        b.pnr_number,
        b.journey_date,
        b.passenger_count,
        b.total_amount,
        b.booking_status,
        b.payment_status,
        b.booking_time,
        t.train_number,
        t.train_name,
        u.name as user_name,
        u.email as user_email,
        COUNT(p.passenger_id) as actual_passengers
    FROM bookings b
    INNER JOIN trains t ON b.train_id = t.train_id
    INNER JOIN users u ON b.user_id = u.user_id
    LEFT JOIN passengers p ON b.booking_id = p.booking_id
    WHERE b.journey_date BETWEEN @FromDate AND @ToDate
      AND (@TrainId IS NULL OR b.train_id = @TrainId)
      AND (@BookingStatus IS NULL OR b.booking_status = @BookingStatus)
    GROUP BY b.booking_id, b.pnr_number, b.journey_date, b.passenger_count, 
             b.total_amount, b.booking_status, b.payment_status, b.booking_time,
             t.train_number, t.train_name, u.name, u.email
    ORDER BY b.booking_time DESC;
END;

-- B. Generate Seat Availability
CREATE PROCEDURE sp_GenerateAvailability
    @TrainId INT,
    @FromDate DATE,
    @ToDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        DECLARE @sleeper INT, @ac3 INT, @ac2 INT;
        
        SELECT @sleeper = sleeper_seats, @ac3 = ac3_seats, @ac2 = ac2_seats
        FROM trains WHERE train_id = @TrainId;
        
        WITH DateRange AS (
            SELECT @FromDate as journey_date
            UNION ALL
            SELECT DATEADD(day, 1, journey_date)
            FROM DateRange
            WHERE journey_date < @ToDate
        )
        INSERT INTO seat_availability (train_id, journey_date, sleeper_available, ac3_available, ac2_available)
        SELECT @TrainId, journey_date, @sleeper, @ac3, @ac2
        FROM DateRange
        WHERE NOT EXISTS (
            SELECT 1 FROM seat_availability sa 
            WHERE sa.train_id = @TrainId AND sa.journey_date = DateRange.journey_date
        )
        OPTION (MAXRECURSION 366);
        
        SELECT 1 as Success, @@ROWCOUNT as RecordsCreated;
        
    END TRY
    BEGIN CATCH
        SELECT 0 as Success, ERROR_MESSAGE() as Message;
    END CATCH
END;

-- =====================================================
-- 8. ADDITIONAL BUSINESS LOGIC PROCEDURES
-- =====================================================

-- A. Update Passenger Seat Assignment
CREATE PROCEDURE sp_AssignSeats
    @BookingId INT,
    @SeatAssignments NVARCHAR(MAX) -- JSON: [{"passengerId":1,"seatNumber":"A1","coachNumber":"S1"}]
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        -- Parse seat assignments (simplified for demo)
        -- In production, use JSON parsing or table-valued parameters
        
        DECLARE @Success BIT = 1;
        
        -- Validate booking exists and is confirmed
        IF NOT EXISTS(SELECT 1 FROM bookings WHERE booking_id = @BookingId AND booking_status = 'confirmed')
        BEGIN
            SELECT 0 as Success, 'Invalid booking or booking not confirmed' as Message;
            RETURN;
        END
        
        -- Log the seat assignment activity
        INSERT INTO admin_logs (admin_id, action, target_table, record_id, details)
        VALUES (1, 'Seat Assignment', 'passengers', @BookingId, 'Seats assigned for booking: ' + CAST(@BookingId AS NVARCHAR));
        
        SELECT 1 as Success, 'Seat assignments updated successfully' as Message;
        
    END TRY
    BEGIN CATCH
        SELECT 0 as Success, ERROR_MESSAGE() as Message;
    END CATCH
END;

-- B. Get Train Occupancy Report
CREATE PROCEDURE sp_GetTrainOccupancy
    @TrainId INT,
    @FromDate DATE,
    @ToDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        b.journey_date,
        t.train_number,
        t.train_name,
        t.total_seats,
        SUM(CASE WHEN p.seat_type = 'sleeper' THEN 1 ELSE 0 END) as sleeper_booked,
        t.sleeper_seats - SUM(CASE WHEN p.seat_type = 'sleeper' THEN 1 ELSE 0 END) as sleeper_available,
        SUM(CASE WHEN p.seat_type = 'ac3' THEN 1 ELSE 0 END) as ac3_booked,
        t.ac3_seats - SUM(CASE WHEN p.seat_type = 'ac3' THEN 1 ELSE 0 END) as ac3_available,
        SUM(CASE WHEN p.seat_type = 'ac2' THEN 1 ELSE 0 END) as ac2_booked,
        t.ac2_seats - SUM(CASE WHEN p.seat_type = 'ac2' THEN 1 ELSE 0 END) as ac2_available,
        COUNT(p.passenger_id) as total_passengers,
        SUM(b.total_amount) as total_revenue,
        CAST((COUNT(p.passenger_id) * 100.0 / t.total_seats) AS DECIMAL(5,2)) as occupancy_percentage
    FROM trains t
    LEFT JOIN bookings b ON t.train_id = b.train_id 
        AND b.journey_date BETWEEN @FromDate AND @ToDate
        AND b.booking_status = 'confirmed'
    LEFT JOIN passengers p ON b.booking_id = p.booking_id AND p.status = 'confirmed'
    WHERE t.train_id = @TrainId
    GROUP BY b.journey_date, t.train_number, t.train_name, t.total_seats, t.sleeper_seats, t.ac3_seats, t.ac2_seats
    ORDER BY b.journey_date;
END;

-- C. Process Waitlist Bookings
CREATE PROCEDURE sp_ProcessWaitlist
    @TrainId INT,
    @JourneyDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        DECLARE @ProcessedCount INT = 0;
        
        -- Get available seats
        DECLARE @SleeperAvailable INT, @AC3Available INT, @AC2Available INT;
        
        SELECT @SleeperAvailable = sleeper_available, 
               @AC3Available = ac3_available, 
               @AC2Available = ac2_available
        FROM seat_availability
        WHERE train_id = @TrainId AND journey_date = @JourneyDate;
        
        -- Process sleeper waitlist
        IF @SleeperAvailable > 0
        BEGIN
            UPDATE TOP(@SleeperAvailable) p
            SET status = 'confirmed'
            FROM passengers p
            INNER JOIN bookings b ON p.booking_id = b.booking_id
            WHERE b.train_id = @TrainId 
              AND b.journey_date = @JourneyDate
              AND p.seat_type = 'sleeper'
              AND p.status = 'waitlist'
              AND b.booking_status = 'waitlist';
            
            SET @ProcessedCount += @@ROWCOUNT;
        END;
        
        -- Update booking status for confirmed passengers
        UPDATE b
        SET booking_status = 'confirmed'
        FROM bookings b
        WHERE b.train_id = @TrainId 
          AND b.journey_date = @JourneyDate
          AND b.booking_status = 'waitlist'
          AND EXISTS (
              SELECT 1 FROM passengers p 
              WHERE p.booking_id = b.booking_id AND p.status = 'confirmed'
          );
        
        COMMIT TRANSACTION;
        
        SELECT 1 as Success, @ProcessedCount as ProcessedPassengers;
        
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        SELECT 0 as Success, ERROR_MESSAGE() as Message;
    END CATCH
END;

-- D. Get Revenue Report
CREATE PROCEDURE sp_GetRevenueReport
    @FromDate DATE,
    @ToDate DATE,
    @TrainId INT = NULL,
    @GroupBy NVARCHAR(10) = 'daily' -- 'daily', 'monthly', 'train'
AS
BEGIN
    SET NOCOUNT ON;
    
    IF @GroupBy = 'daily'
    BEGIN
        SELECT 
            b.journey_date,
            COUNT(DISTINCT b.booking_id) as total_bookings,
            SUM(b.passenger_count) as total_passengers,
            SUM(b.total_amount) as total_revenue,
            SUM(CASE WHEN b.booking_status = 'cancelled' THEN p.refund_amount ELSE 0 END) as total_refunds,
            SUM(b.total_amount) - SUM(CASE WHEN b.booking_status = 'cancelled' THEN p.refund_amount ELSE 0 END) as net_revenue
        FROM bookings b
        LEFT JOIN payments p ON b.booking_id = p.booking_id
        WHERE b.journey_date BETWEEN @FromDate AND @ToDate
          AND (@TrainId IS NULL OR b.train_id = @TrainId)
        GROUP BY b.journey_date
        ORDER BY b.journey_date;
    END
    ELSE IF @GroupBy = 'train'
    BEGIN
        SELECT 
            t.train_number,
            t.train_name,
            COUNT(DISTINCT b.booking_id) as total_bookings,
            SUM(b.passenger_count) as total_passengers,
            SUM(b.total_amount) as total_revenue,
            AVG(b.total_amount) as avg_booking_value
        FROM bookings b
        INNER JOIN trains t ON b.train_id = t.train_id
        WHERE b.journey_date BETWEEN @FromDate AND @ToDate
          AND (@TrainId IS NULL OR b.train_id = @TrainId)
        GROUP BY t.train_id, t.train_number, t.train_name
        ORDER BY total_revenue DESC;
    END;
END;

-- =====================================================
-- 9. NOTIFICATION & COMMUNICATION PROCEDURES
-- =====================================================

-- A. Get Booking Notifications
CREATE PROCEDURE sp_GetBookingNotifications
    @UserId INT,
    @NotificationType NVARCHAR(20) = NULL -- 'booking', 'cancellation', 'waitlist'
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Return booking-related notifications
    SELECT 
        'booking_confirmation' as notification_type,
        b.pnr_number,
        'Your booking ' + b.pnr_number + ' for ' + t.train_name + ' on ' + 
        CONVERT(NVARCHAR, b.journey_date, 106) + ' is confirmed' as message,
        b.booking_time as created_at,
        CASE WHEN DATEDIFF(hour, b.booking_time, GETDATE()) <= 24 THEN 1 ELSE 0 END as is_new
    FROM bookings b
    INNER JOIN trains t ON b.train_id = t.train_id
    WHERE b.user_id = @UserId 
      AND b.booking_status = 'confirmed'
      AND (@NotificationType IS NULL OR @NotificationType = 'booking')
    
    UNION ALL
    
    SELECT 
        'waitlist_notification' as notification_type,
        b.pnr_number,
        'Your booking ' + b.pnr_number + ' is in waitlist. We will notify you if seats become available' as message,
        b.booking_time as created_at,
        CASE WHEN DATEDIFF(hour, b.booking_time, GETDATE()) <= 24 THEN 1 ELSE 0 END as is_new
    FROM bookings b
    WHERE b.user_id = @UserId 
      AND b.booking_status = 'waitlist'
      AND (@NotificationType IS NULL OR @NotificationType = 'waitlist')
    
    ORDER BY created_at DESC;
END;

-- B. Get Journey Reminders
CREATE PROCEDURE sp_GetJourneyReminders
    @ReminderDate DATE = NULL -- NULL for today's journeys
AS
BEGIN
    SET NOCOUNT ON;
    
    SET @ReminderDate = ISNULL(@ReminderDate, CAST(GETDATE() AS DATE));
    
    SELECT 
        u.user_id,
        u.name,
        u.email,
        u.phone,
        b.pnr_number,
        t.train_number,
        t.train_name,
        s1.station_name as source_station,
        s2.station_name as destination_station,
        t.departure_time,
        b.journey_date,
        'Your train ' + t.train_name + ' (' + t.train_number + ') departs today at ' + 
        CONVERT(NVARCHAR, t.departure_time, 108) + ' from ' + s1.station_name as reminder_message
    FROM bookings b
    INNER JOIN users u ON b.user_id = u.user_id
    INNER JOIN trains t ON b.train_id = t.train_id
    INNER JOIN stations s1 ON t.source_station_id = s1.station_id
    INNER JOIN stations s2 ON t.destination_station_id = s2.station_id
    WHERE b.journey_date = @ReminderDate
      AND b.booking_status = 'confirmed'
      AND u.is_active = 1
    ORDER BY t.departure_time;
END;

-- =====================================================
-- 10. DATA VALIDATION & BUSINESS RULES
-- =====================================================

-- A. Validate Booking Request
CREATE PROCEDURE sp_ValidateBookingRequest
    @UserId INT,
    @TrainId INT,
    @JourneyDate DATE,
    @PassengerCount INT,
    @SeatType NVARCHAR(10)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @ValidationErrors TABLE (error_message NVARCHAR(200));
    
    -- Check user exists and is active
    IF NOT EXISTS(SELECT 1 FROM users WHERE user_id = @UserId AND is_active = 1)
        INSERT INTO @ValidationErrors VALUES ('Invalid or inactive user');
    
    -- Check train exists and is active
    IF NOT EXISTS(SELECT 1 FROM trains WHERE train_id = @TrainId AND is_active = 1)
        INSERT INTO @ValidationErrors VALUES ('Invalid or inactive train');
    
    -- Check journey date is not in past
    IF @JourneyDate < CAST(GETDATE() AS DATE)
        INSERT INTO @ValidationErrors VALUES ('Journey date cannot be in the past');
    
    -- Check journey date is within booking window (120 days)
    IF @JourneyDate > DATEADD(day, 120, CAST(GETDATE() AS DATE))
        INSERT INTO @ValidationErrors VALUES ('Booking not allowed beyond 120 days');
    
    -- Check train runs on selected date
    IF dbo.fn_IsValidJourneyDate(@TrainId, @JourneyDate) = 0
        INSERT INTO @ValidationErrors VALUES ('Train does not run on selected date');
    
    -- Check passenger count limits
    IF @PassengerCount <= 0 OR @PassengerCount > 6
        INSERT INTO @ValidationErrors VALUES ('Passenger count must be between 1 and 6');
    
    -- Check seat type is valid for train
    DECLARE @SeatExists BIT = 0;
    
    SELECT @SeatExists = CASE 
        WHEN @SeatType = 'sleeper' AND sleeper_seats > 0 THEN 1
        WHEN @SeatType = 'ac3' AND ac3_seats > 0 THEN 1
        WHEN @SeatType = 'ac2' AND ac2_seats > 0 THEN 1
        ELSE 0
    END
    FROM trains WHERE train_id = @TrainId;
    
    IF @SeatExists = 0
        INSERT INTO @ValidationErrors VALUES ('Selected seat type not available in this train');
    
    -- Return validation results
    IF EXISTS(SELECT 1 FROM @ValidationErrors)
    BEGIN
        SELECT 0 as IsValid, error_message as ValidationMessage
        FROM @ValidationErrors;
    END
    ELSE
    BEGIN
        SELECT 1 as IsValid, 'Validation successful' as ValidationMessage;
    END
END;

-- B. Check Duplicate Booking
CREATE PROCEDURE sp_CheckDuplicateBooking
    @UserId INT,
    @TrainId INT,
    @JourneyDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @ExistingPNR NVARCHAR(20) = NULL;
    
    SELECT TOP 1 @ExistingPNR = pnr_number
    FROM bookings
    WHERE user_id = @UserId
      AND train_id = @TrainId
      AND journey_date = @JourneyDate
      AND booking_status IN ('confirmed', 'waitlist');
    
    IF @ExistingPNR IS NOT NULL
    BEGIN
        SELECT 1 as HasDuplicate, @ExistingPNR as ExistingPNR, 
               'You already have a booking for this train on this date' as Message;
    END
    ELSE
    BEGIN
        SELECT 0 as HasDuplicate, NULL as ExistingPNR, 'No duplicate booking found' as Message;
    END
END;

-- =====================================================
-- Example ADO.NET Usage in C#:
-- =====================================================
/*
// Complete Booking Workflow Example:

// 1. User Registration
using (SqlCommand cmd = new SqlCommand("sp_RegisterUser", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@Name", "John Doe");
    cmd.Parameters.AddWithValue("@Email", "john@email.com");
    cmd.Parameters.AddWithValue("@Phone", "9876543210");
    cmd.Parameters.AddWithValue("@Password", hashedPassword);
    cmd.Parameters.AddWithValue("@DateOfBirth", new DateTime(1990, 5, 15));
    cmd.Parameters.AddWithValue("@Gender", "male");
}

// 2. User Login
using (SqlCommand cmd = new SqlCommand("sp_LoginUser", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@Email", email);
    cmd.Parameters.AddWithValue("@Password", hashedPassword);
}

// 3. Search Stations
using (SqlCommand cmd = new SqlCommand("sp_SearchStations", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@SearchTerm", "Mumbai");
}

// 4. Search Trains
using (SqlCommand cmd = new SqlCommand("sp_SearchTrains", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@SourceStationId", sourceStationId);
    cmd.Parameters.AddWithValue("@DestinationStationId", destStationId);
    cmd.Parameters.AddWithValue("@JourneyDate", journeyDate);
    cmd.Parameters.AddWithValue("@SeatType", "sleeper");
    cmd.Parameters.AddWithValue("@PassengerCount", passengerCount);
}

// 5. Validate Booking
using (SqlCommand cmd = new SqlCommand("sp_ValidateBookingRequest", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@UserId", userId);
    cmd.Parameters.AddWithValue("@TrainId", trainId);
    cmd.Parameters.AddWithValue("@JourneyDate", journeyDate);
    cmd.Parameters.AddWithValue("@PassengerCount", passengerCount);
    cmd.Parameters.AddWithValue("@SeatType", seatType);
}

// 6. Check Duplicate
using (SqlCommand cmd = new SqlCommand("sp_CheckDuplicateBooking", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@UserId", userId);
    cmd.Parameters.AddWithValue("@TrainId", trainId);
    cmd.Parameters.AddWithValue("@JourneyDate", journeyDate);
}

// 7. Make Booking
using (SqlCommand cmd = new SqlCommand("sp_MakeBooking", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@UserId", userId);
    cmd.Parameters.AddWithValue("@TrainId", trainId);
    cmd.Parameters.AddWithValue("@JourneyDate", journeyDate);
    cmd.Parameters.AddWithValue("@PassengerCount", passengers.Count);
    cmd.Parameters.AddWithValue("@SeatType", seatType);
    cmd.Parameters.AddWithValue("@PaymentMethod", "UPI");
    cmd.Parameters.AddWithValue("@TransactionId", transactionId);
    cmd.Parameters.AddWithValue("@PassengerNames", string.Join(",", passengers.Select(p => p.Name)));
    cmd.Parameters.AddWithValue("@PassengerAges", string.Join(",", passengers.Select(p => p.Age)));
    cmd.Parameters.AddWithValue("@PassengerGenders", string.Join(",", passengers.Select(p => p.Gender)));
    
    // Output parameters
    cmd.Parameters.Add("@BookingId", SqlDbType.Int).Direction = ParameterDirection.Output;
    cmd.Parameters.Add("@PNRNumber", SqlDbType.NVarChar, 20).Direction = ParameterDirection.Output;
    cmd.Parameters.Add("@TotalAmount", SqlDbType.Decimal).Direction = ParameterDirection.Output;
    cmd.Parameters.Add("@Status", SqlDbType.NVarChar, 20).Direction = ParameterDirection.Output;
    
    cmd.ExecuteNonQuery();
    
    int bookingId = (int)cmd.Parameters["@BookingId"].Value;
    string pnr = cmd.Parameters["@PNRNumber"].Value.ToString();
    decimal amount = (decimal)cmd.Parameters["@TotalAmount"].Value;
    string status = cmd.Parameters["@Status"].Value.ToString();
}

// 8. Get Booking Details
using (SqlCommand cmd = new SqlCommand("sp_GetBookingDetails", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@PNRNumber", pnrNumber);
    cmd.Parameters.AddWithValue("@UserId", userId);
}

// 9. Get User Bookings with Pagination
using (SqlCommand cmd = new SqlCommand("sp_GetUserBookings", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@UserId", userId);
    cmd.Parameters.AddWithValue("@BookingStatus", DBNull.Value); // All statuses
    cmd.Parameters.AddWithValue("@PageNumber", pageNumber);
    cmd.Parameters.AddWithValue("@PageSize", pageSize);
}

// 10. Cancel Booking
using (SqlCommand cmd = new SqlCommand("sp_CancelBooking", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    cmd.Parameters.AddWithValue("@PNRNumber", pnrNumber);
    cmd.Parameters.AddWithValue("@UserId", userId);
    cmd.Parameters.AddWithValue("@CancellationReason", reason);
}
*/